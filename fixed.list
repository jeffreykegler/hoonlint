cenlus hoon hoon hoon
cendot hoon hoon
cenket hoon hoon hoon hoon
censig wing hoon (list hoon)
cenhep hoon hoon
bucpat model model
buctis @tas model
buccab hoon
bucket model model
buchep model model
semsem model value
barcol hoon hoon
bartis model hoon
barwut hoon
bardot hoon
bartar model hoon
barsig model hoon
barhep hoon
wutgal hoon hoon
wutgar hoon hoon
wutpat wing hoon hoon
wutcol hoon hoon hoon
wuttis model wing
wutdot hoon hoon hoon
wutket wing hoon hoon
# `?^ "wutket"`
wutzap hoon

---
navhome: /docs/
next: true
sort: 9
title: ?~ "wutsig"
---

# `?~ "wutsig"` 

`[%wtsg p=wing q=hoon r=hoon]`: branch on whether a wing 
of the subject is null.
 
## Expands to

```
?:(?=($~ p) q r)
```

## Syntax

Regular: *3-fixed*.

## Discussion

It's bad style to use `?~` to test for any zero atom.  Use it
only for a true null, `~`.

## Examples

```
~zod:dojo> =foo ""
~zod:dojo> ?~(foo 1 2)
1
```
---
navhome: /docs/
sort: 12
title: ~< "siggal"
---

# `~< "siggal"` 

`[%sggl p=$@(term [p=term q=hoon]) q=hoon]`: raw hint, applied to 
product.

## Expands to

`q`.

## Syntax

Regular: *2-fixed*.  For the dynamic form, write `%term.hoon`.

## Discussion

`~<` ("siggal") is only used for jet hints ([`~/` ("sigfas")](../fas/) 
and [`~%` ("sigcen")](../cen/)) at the moment; we are not telling the 
interpreter something about the computation we're about to perform, but 
rather about its product.

## Examples

```
~zod:dojo> (make '~<(%a 42)')
[%7 p=[%1 p=42] q=[%10 p=97 q=[%0 p=1]]]
~zod:dojo> (make '~<(%a.+(.) 42)')
[%7 p=[%1 p=42] q=[%10 p=[p=97 q=[%4 p=[%0 p=1]]] q=[%0 p=1]]]
```
---
navhome: /docs/
next: true
sort: 6
title: ~+ "siglus"
---

# `~+ "siglus"`

`[%sgls p=hoon]`: cache a computation.

## Expands to

`p`.

## Convention

Caches the formula and subject of `p` in a local cache (generally 
transient in the current event).

## Syntax

Regular: *1-fixed*.

## Examples

This may pause for a second:

```
~zod:dojo> %.(25 |=(a=@ ?:((lth a 2) 1 (add $(a (sub a 2)) $(a (dec a))))))
121.393
```

This may make you want to press `ctrl-c`:

```
~zod:dojo> %.(30 |=(a=@ ?:((lth a 2) 1 (add $(a (sub a 2)) $(a (dec a))))))
1.346.269
```

This should work fine:

```
~zod:dojo> %.(100 |=(a=@ ~+(?:((lth a 2) 1 (add $(a (sub a 2)) $(a (dec a)))))))
573.147.844.013.817.084.101
```
---
navhome: /docs/
next: true
sort: 11
title: ~> "siggar"
---

# `~> "siggar"`

`[%sggr p=$@(term [p=term q=hoon]) q=hoon]`: raw hint, applied
to computation.

## Expands to

`q`.

## Syntax

Regular: *2-fixed*.  For the dynamic form, write `%term.hoon`.

## Discussion

Hoon has no way of telling what hints are used and what aren't.
Hints are all conventions at the interpreter level.

## Examples

```
~zod:dojo> ~>(%a 42)
42
```

Running the compiler:

```
~zod:dojo> (make '~>(%a 42)')
[%10 p=97 q=[%1 p=42]]

~zod:dojo> (make '~>(%a.+(2) 42)')
[%10 p=[p=97 q=[%4 p=[%1 p=2]]] q=[%1 p=42]]
```
---
navhome: /docs/
next: true
sort: 8
title: ~$ "sigbuc"
---

# `~$ "sigbuc"`

`[%sgbc p=term q=hoon]`: profiling hit counter.

## Expands to

`q`.

## Convention

If profiling is on, adds 1 to the hit counter for `p`.

## Syntax

Regular: *2-fixed*.

## Examples

```
~zod:dojo> ~$(%foo 3)
3
```
---
navhome: /docs/
next: true
sort: 2
title: ~? "sigwut"
---

# `~? "sigwut"`

`[%sgwt p=hoon q=hoon r=hoon]`: conditional debug printf.

## Expands to

`r`.

## Convention 

If `p` is true, prettyprints `q` on the console before computing `r`.

## Syntax

Regular: *4-fixed*.

## Examples

```
~zod:dojo> ~?((gth 1 2) 'oops' ~)
~

~zod:dojo> ~?((gth 1 0) 'oops' ~)
'oops'
~

~zod:dojo> ~?  (gth 1 2) 
             'oops' 
           ~
~

~zod:dojo> ~?  (gth 1 0) 
             'oops'
           ~
'oops'
~
```
---
navhome: /docs/
next: true
sort: 9
title: ~/ "sigfas"
---

# `~/ "sigfas"`

`[%sgfs p=term q=hoon]`: jet registration for gate with
registered context.

## Expands to

```
~%(p +7 ~ q)
```

## Syntax

Regular: *2-fixed*.

## Examples

From the kernel: 
```
++  add
  ~/  %add
  |=  [a=@ b=@]
  ^-  @
  ?:  =(0 a)  b
  $(a (dec a), b +(b))
```
---
navhome: /docs/
next: true
sort: 3
title: ~! "sigzap"
---

# `~! "sigzap"` 

`[%sgzp p=hoon q=hoon]`: print type on compilation fail.

## Expands to

`q`.

## Convention

If compilation of `q` fails, prints the type of `p` in the trace.

## Syntax

Regular: *2-fixed*.

## Examples

```
~zod:dojo> a
! -find.a

~zod:dojo> ~!('foo' a)
! @t
! find.a

~zod:dojo> ~!  'foo' 
           a
! @t
! find.a
```
---
navhome: /docs/
next: true
sort: 10
title: ~% "sigcen"
---

# `~% "sigcen"`

`[%sgcn p=term q=wing r=(list [term hoon]) s=hoon]`: jet registration.

## Expands to

`s`.

## Convention

Register a core with name `p`, with parent at leg `q`, exporting
the named formulas `r`, constructed by `s`.

## Syntax

Regular: *4-fixed*.  For `r`, use `~` if empty.  Otherwise, *jogging* 
between opening and closing `==`.

## Discussion

`~%` ("sigcen" is for registering cores.  A registered core declares its
formal identity to the interpreter, which may or may not be able
to recognize and/or accelerate it.

Registered cores are organized in a containment hierarchy.
The parent core is at any leg within the child core.  When we
register a core, we state the leg to its parent, in the form of
wing `q`.  We assume the parent is already registered -- as it
must be, if (a) we registered it on creation, (b) the child was
created by an arm defined on the parent.

(Cores are actually managed by their formula/battery.  Any
function call will create a new core with a new sample, but
batteries are constant.  But it is not sufficient to match the
battery -- matching the semantics constrains the payload as well,
since the semantics of a battery may depend on any parent core
and/or payload constant.)

The purpose of registration is always performance-related.  It
may involve (a) a special-purpose optimizer or "jet", written
for a specific core and checked with a Merkle hash; (b) a
general-purpose hotspot optimizer or "JIT"; or (c) merely a
hotspot declaration for profiling.

As always with hints, the programmer has no idea which of (a),
(b), and (c) will be applied.  She should use `~%`
indiscriminately on all hotspots, bottlenecks, etc, real or
suspected.

The list `r` is a way for the Hoon programmer to help jet
implementors with named Nock formulas that act on the core.
In complex systems, jet implementations are often partial and
want to call back into userspace.

The child core contains the parent, of course.  When we register
a core, we state the leg to its parent, in the form of wing `q`.
We assume that the parent -- any core within the payload -- is
already registered.

must already be registered.
The interpreter can thus 

`p` is the name of this core within its parent; `q` is a the leg 

Registers a jet in core `s` so that it can be called when that code is run.

Regularm form: *4-fixed*

## Examples

Here's the AES 

    ++  aesc                                                ::  AES-256
      ~%  %aesc  +  ~
      |%
      ++  en                                                ::  ECB enc
        ~/  %en
        |=  [a=@I b=@H]  ^-  @uxH
        =+  ahem
        (be & (ex a) b)
      ++  de                                                ::  ECB dec
        ~/  %de
        |=  [a=@I b=@H]  ^-  @uxH
        =+  ahem
        (be | (ix (ex a)) b)
      --

Here we label the entire `++aesc` core for optimization. You can see the
jet in `jets/e/aesc.c`.
---
navhome: /docs/
next: true
sort: 4
title: ~| "sigbar"
---

# `~| "sigbar"`

`[%sgbr p=hoon q=hoon]`: tracing printf.

## Expands to

`q`.

## Convention

Prettyprints `p` in stack trace if `q` crashes.

## Syntax

Regular: *2-fixed*.

## Examples

```
~zod:dojo> ~|('sample error message' !!)
'sample error message'
ford: build failed

~zod:dojo> ~|  'sample error message' 
           !!
'sample error message'
ford: build failed
```
---
navhome: /docs/
next: true
sort: 1
title: ~& "sigpam"
---

# `~& "sigpam"`

`[%sgpm p=hoon q=hoon]`: debugging printf.

## Expands to

`q`.

## Convention

Prettyprints `p` on the console before computing `q`. 

## Syntax

Regular: *2-fixed*.

## Examples

```
~zod:dojo> ~&('halp' ~)
'halp'
~

~zod:dojo> ~&  'halp' 
           ~
'halp'
~
```
---
navhome: /docs/
next: true
sort: 2
title: ^+ "ketlus"
---

# `^+ "ketlus"`

`[%ktls p=value q=value]`: typecast by example (hoon).

## Produces

The value of `q` with the type of `p`, if the type of `q` nests
within the type of `p`.  Otherwise, `nest-fail`.

## Syntax

Regular: *2-fixed*.

## Examples

```
~zod:dojo> ^+('text' %a)
'a'
```
---
navhome: /docs/
next: true
sort: 3
title: ^= "kettis"
---


# `^= "kettis"`

`[%ktts p=toga q=value]`: name a value.

## Produces

If `p` is a term, the product `q` with type `[%face p q]`.  `p`
may also be a tuple of terms, or a term-toga pair; the type of 
`q` must divide evenly into cells to match it.

## Syntax

Regular: *2-fixed*.

Irregular: `foo=bar` is `^=(foo bar)`.

## Examples

```
~zod:dojo> a=1
a=1
~zod:dojo> ^=  a
           1
a=1
~zod:dojo> ^=(a 1)
a=1
~zod:dojo> [b c d]=[1 2 3 4]
[b=1 c=2 d=[3 4]]
~zod:dojo> [b c d=[x y]]=[1 2 3 4]
[b=1 c=2 d=[x=3 y4]]
```
---
navhome: /docs/
sort: 6
title: ^? "ketwut"
---

# `^? "ketwut"`

`[%ktwt p=hoon]`: convert any core to a lead core (bivariant).

## Produces

`p` as a lead core; crash if not a core.

## Syntax

Regular: *1-fixed*.

## Discussion

A lead core is an opaque generator; the payload can't be read or 
written.

Theorem: if type `x` nests within type `a`, a lead core producing
`x` nests within a lead core producing `a`.

Informally, a more specific generator can be used as a less
specific generator.

## Examples

The prettyprinter shows the core metal (`.` gold, `?` lead):

```
~zod:dojo> |=(@ 1)
<1.gcq [@  @n <250.yur 41.wda 374.hzt 100.kzl 1.ypj %151>]>
~zod:dojo> ^?(|=(@ 1))
<1?gcq [@  @n <250.yur 41.wda 374.hzt 100.kzl 1.ypj %151>]>
```

---
navhome: /docs/
next: true
sort: 4
title: ^~ "ketsig"
---

# `^~ "ketsig"`

`[%ktsg p=hoon]`: fold constant at compile time.

## Produces

`p`, folded as a constant if possible.

## Syntax

Regular: *1-fixed*.

## Examples

```
~zod:dojo> (make '|-(42)')
[%8 p=[%1 p=[1 42]] q=[%9 p=2 q=[%0 p=1]]]
~zod:dojo> (make '^~(|-(42))')
[%1 p=42]
```

---
navhome: /docs/
next: true
sort: 5
title: ^| "ketbar"
---

# `^| "ketbar"`

`[%ktbr p=hoon]`: convert a gold core to an iron core (contravariant).

## Produces

`p` as an iron core; crash if not a gold core.

## Syntax

Regular: *1-fixed*.

## Discussion

An iron core is an opaque function (gate or door).

Theorem: if type `x` nests within type `a`, and type `y` nests
within type `b`, a core accepting `b` and producing `x` nests
within a iron core accepting `y` and producing `a`.

Informally, a function fits an interface if the function has a
more specific result and/or a less specific argument than the
interface.

## Examples

The prettyprinter shows the core metal (`.` gold, `|` iron):

```
~zod:dojo> |=(@ 1)
<1.gcq [@  @n <250.yur 41.wda 374.hzt 100.kzl 1.ypj %151>]>
~zod:dojo> ^|(|=(@ 1))
<1|gcq [@  @n <250.yur 41.wda 374.hzt 100.kzl 1.ypj %151>]>
```

---
navhome: /docs/
next: true
sort: 1
title: ^- "kethep"
---

# `^- "kethep"`

`[%kthp p=model q=value]`: typecast by mold.

## Expands to

```
^+(*p q)
```

## Syntax

Regular: *2-fixed*.

Irregular: `` `foo`bar`` is `^-(foo bar)`.

## Discussion

It's a good practice to put a `^-` ("kethep") at the top of every arm
(including gates, loops, etc).  This cast is strictly necessary
only in the presence of head recursion (otherwise you'll get a
`rest-loop` error, or if you really screw up spectacularly an 
infinite loop in the compiler).

## Examples

```
~zod:dojo> (add 90 7)
97
~zod:dojo> `@t`(add 90 7)
'a'
~zod:dojo> ^-(@t (add 90 7))
'a'
/~zod:dojo> =foo  |=  a=@tas
                  ^-  (unit @ta)
                  `a
/~zod:dojo> (foo 97)
[~ ~.a]
```
---
navhome: /docs/
next: true
sort: 3
title: :+ "collus"
---

# `:+ "collus"`

`[%clls p=hoon q=hoon r=hoon]`: construct a triple (3-tuple).

## Expands to:

```
:-(p :-(q r))
```

## Syntax

Regular: *3-fixed*.

## Examples

```
/~zod:dojo> :+  1
              2
            3
[1 2 3]
/~zod:dojo> :+(%a ~ 'b')
[%a ~ 'b']
```
---
navhome: /docs/
next: true
sort: 2
title: :_ "colcab"
---

# `:_ "colcab"`

`[%clcb p=hoon q=hoon]`; construct a cell, inverted.

### Expands to

```
:-(q p)
```

### Syntax

Regular: *2-fixed*.

### Examples

```
~zod:dojo> :_(1 2)
[2 1]
```
---
navhome: /docs/
next: true
sort: 4
title: :^ "colket"
---

# `:^ "colket"`

`[%clkt p=hoon q=hoon r=hoon s=hoon]`: construct a quadruple (4-tuple).

## Expands to

```
:-(p :-(q :-(r s)))
```

## Syntax

Regular: *4-fixed*.

## Examples

```
/~zod:dojo> :^(1 2 3 4)
[1 2 3 4]
/~zod:dojo> :^     5
                 6
               7
             8
[5 6 7 8]
```
---
navhome: /docs/
next: true
sort: 1
title: :- "colhep"
---

# `:- "colhep"`

`[%clhp p=hoon q=hoon]`: construct a cell (2-tuple).

## Produces

The cell of `p` and `q`.

## Syntax

Regular: *2-fixed*.

Irregular: `[a b]` is `:-(a b)`.

Irregular: `[a b c]` is `[a [b c]]`.

Irregular: `a^b^c` is `[a b c]`.

Irregular: `a/b` is `[%a b]`.

Irregular: `` `a `` is `[~ a]`.

Irregular: `~[a b]` is `[a b ~]`.

Irregular: `[a b c]~` is `[[a b c] ~]`.

## Discussion

Hoon hoons actually use the same "autocons" pattern as Nock 
formulas.  If you're assembling hoons (which usually only the
compiler does), `[a b]` is the same as `[%clhp a b]`.

## Examples

```
~zod:dojo> :-(1 2)
[1 2]
~zod:dojo> 1^2
[1 2]
~zod:dojo> 1/2
[%1 2]
~zod:dojo> `1
[~ 1]
```
---
navhome: /docs/
next: true
sort: 3
title: .+ "dotlus"
---

# `.+ "dotlus"`

`[%dtls p=atom]`: increment an atom with Nock `4`.

## Produces

`p` plus `1` if `p` is an atom; otherwise, crashes.  The product
atom has no aura.

## Syntax

Regular: *1-fixed*.

Irregular: `+(6)` is `.+(6)`.

## Examples

```
~zod:dojo> .+(6)
7
~zod:dojo> +(6)
7
~zod:dojo> +(%foo)
7.303.015
~zod:dojo> +([1 2])
! nest-fail
```
---
navhome: /docs/
next: true
sort: 4
title: .= "dottis"
---

# `.=  "dottis"` 

`[%dtts p=hoon q=hoon]`: test for equality with Nock `5`.

## Produces

`&`, `%.y`, `0` if `p` equals `q`; otherwise `|`, `%.n`, `1`.

## Syntax

Regular: *2-fixed*.

Irregular: `=(a b)` is `.=(a b)`.

## Discussion

Like Nock equality, `.=` ("dottis") tests if two nouns are the same,
ignoring invisible pointer structure.  Because in a conventional
noun implementation each noun has a lazy short hash, comparisons 
are fast unless the hash needs to be computed, or we are comparing
separate copies of identical nouns.  (Comparing large duplicates 
is a common cause of performance bugs.)

## Examples

```
~zod:dojo> .=(0 0)
%.y
~zod:dojo> =(0 0)
%.y
~zod:dojo> .=(1 2)
%.n
~zod:dojo> =(1 2)
%.n
```
---
navhome: /docs/
next: true
sort: 2
title: .? "dotwut"
---

# `.? "dotwut"`

`[%dtwt p=hoon]`: test for cell or atom with Nock `3`.

## Produces

`&`, `%.y`, `0` if `p` is a cell; otherwise `|`, `%.n`, `1`.

## Syntax

Regular: *1-fixed*.

## Examples

```
~zod:dojo> .?(42)
%.n
~zod:dojo> .?([42 43])
%.y
```
---
navhome: /docs/
next: true
sort: 1
title: .* "dottar"
---

# `.* "dottar"`

`[%dttr p=hoon q=hoon]`: evaluate with Nock `2`.

## Produces

Nock of formula `q` and subject `p`, with type `%noun`.

## Syntax

Regular: *2-fixed*.

## Discussion

Note that `.*` ("dottar") can be used to bypass the type system,
though its product contains no type information.  It's
perfectly practical to use Hoon as a typeless language.

## Examples

```
~zod:dojo> .*([20 30] [0 2])
20
~zod:dojo> .*(33 [4 0 1])
34
~zod:dojo> .*(|.(50) [9 2 0 1])
50
~zod:dojo> .*(12 [7 [`1 [4 `1]] [`2 `3 `2]])
[12 13 12]
~zod:dojo> .*(~ [5 1^4 [4 1^3]])
0
~zod:dojo> .*(~ [5 1^5 [4 1^3]])
1
```
---
navhome: /docs/
next: true
sort: 7
title: =; "tissem"
---

# `=; "tissem"`

`[%tssm p=taco q=hoon r=hoon]`: combine a named and/or typed noun with the
subject, inverted.

## Expands to

```
=/(p r q)
```

## Syntax

Regular: *3-fixed*.

## Examples

```
~zod:dojo> =foo  |=  a=@
                 =/   b  1
                 =;   c=@  :(add a b c)
                 2
~zod:dojo> (foo 5)
8
```
---
navhome: /docs/
next: true
sort: 2
title: =< "tisgal"
---

# `=< "tisgal"`

`[%tsgl p=hoon q=hoon]`: compose two hoons, inverted.

## Expands to

```
=>(q p)
```

## Syntax

Regular: *2-fixed*.

Irregular: `foo:bar` is `=<(foo bar)`.

## Examples

```
~zod:dojo> =<(b [a=1 b=2 c=3])
2

~zod:dojo> =<  b 
           [a=1 b=2 c=3]
2

~zod:dojo> b:[a=1 b=2 c=3]
2

~zod:dojo> [. .]:(add 2 4)
[6 6]
```
---
navhome: /docs/
next: true
sort: 4
title: =+ "tislus"
---

# `=+ "tislus"`

`[%tsls p=hoon q=hoon]`: combine a new noun with the subject.

## Expands to

```
=>([p .] q)
```

## Syntax

Regular: *2-fixed*.

## Discussion

`=+` ("tislus") is the simplest way of "declaring a variable."

## Examples
 
```
~zod:dojo> =foo |=  a=@
                =+  b=1
                =+  c=2
                :(add a b c)
~zod:dojo> (foo 5)
8
```
---
navhome: /docs/
next: true
sort: 1
title: => "tisgar"
---

# `=> "tisgar"` 

`[%tsgr p=hoon q=hoon]`: compose two hoons.

## Produces

`q`, compiled against the product of `p`.

## Syntax

Regular: *2-fixed*.

## Examples

```
~zod:dojo> =>([a=1 b=2 c=3] b)
2
~zod:dojo> =>((add 2 4) [. .])
[6 6]
```
---
navhome: /docs/
next: true
sort: 13
title: =? "tiswut"
---

# `=? "tiswut"`

`[$tswt p/wing q/hoon r/hoon s/hoon]`: conditionally change one leg in the subject.

## Expands to

```
=.  p  ?:(q r p)
s
```

## Syntax

Regular: *4-fixed*.

## Discussion

Use `=?` to replace the value of leg `p` with `r` on condition `q`. As
usual, we are not actually mutating the subject, just creating
a new subject with a changed value.  The change in value includes a
type check against the old subject; the type of `r` must nest under
the type of `p`.

## Examples

```
> =a 12

> =?(a =(1 1) 22 a)
22

> =?(a =(1 2) 22 a)
12
```
---
navhome: /docs/
next: true
sort: 10
title: =. "tisdot"
---

# `=. "tisdot"` 

`[%tsdt p=wing q=hoon r=hoon]`: change one leg in the subject.

## Expands to

```
=>(%_(. p q) r)
```

## Syntax

Regular: *3-fixed*.

## Discussion

As usual, we are not actually mutating the subject, just creating
a new subject with a changed value.  Note that the mutation uses
[`%_` ("cencab")](../../cen/cab/), so the type doesn't change.

## Examples

```
~zod:dojo> =+  a=[b=1 c=2]
           =.  b.a  3
           a
[b=3 c=2]

~zod:dojo> =+  a=[b=1 c=2]
           =.(b.a 3 a)
[b=3 c=2]
```
---
navhome: /docs/
next: true
sort: 9
title: =* "tistar"
---

# `=* "tistar"`

`[%tstr p=term q=hoon r=hoon]`: define an alias.

## Produces

`r`, compiled with a subject in which `p` is aliased to `q`.

## Syntax

Regular: *3-fixed*.

## Discussion

The difference between aliasing and pinning is that the subject
noun stays the same; the alias is just recorded in its type.
`q` is calculated every time you use the `p` alias, of course.

## Examples

```
~zod:dojo>
    =+  a=1
    =*  b  a
    [a b]
[1 1]

~zod:dojo>
    =+  a=1
    =*  b  a
    =.  a  2
    [a b]
[2 2]
```
---
navhome: /docs/
next: true
sort: 6
title: =/ "tisfas"
---

# `=/ "tisfas"` 

`[%tsfs p=taco q=hoon r=hoon]`: combine a named and/or typed 
noun with the subject.

## Expands to

*if `p` is a symbol*:

```
=+(^=(p q) r)
```

*if `p` is a symbol with a mold*:

```
=+(^-(p q) r)
```

### Compiler macro

```
?@  p
  =+  p=q
  r
=+  ^-($=(p.p q.p) q)
r
```

## Syntax

Regular: *3-fixed*.

## Discussion

`p` can be either a symbol or a symbol/mold.  If it's just a symbol,
`=/` ("tisfas") "declares a type-inferred variable."  If it has a mold, `=/`
"declares a type-checked variable."

## Examples

```
~zod:dojo> =foo  |=  a=@
                 =/  b  1
                 =/  c=@  2
                 :(add a b c)
~zod:dojo> (foo 5)
8
```

---
navhome: /docs/
sort: 12
title: =^ "tisket"
---

# `=^ "tisket"`

`[%tskt p=taco q=wing r=hoon s=hoon]`: pin the head of a pair; change 
a leg with the tail.

## Expands to

```
=/(p -.r =.(q +.r s))
```

## Syntax

Regular: *4-fixed*.

## Discussion

We use `=^` ("tisket" when we have a state machine with a function that
produces a cell, whose head is a result and whose tail is a new
state.  We want to use the head as a new variable, and stuff the
tail back into wherever we stored the old state.

This may also remind you of Haskell's State monad.

## Examples

The `og` core is a stateful pseudo-random number generator.
We have to change the core state every time we generate a
random number, so we use `=^`:

```
~zod:dojo> =+  rng=~(. og 420)
           =^  r1  rng  (rads:rng 100)
           =^  r2  rng  (rads:rng 100)
           [r1 r2]
[99 46]
```
---
navhome: /docs/
next: true
sort: 8
title: =| "tisbar"
---

# `=| "tisbar"`

`[%tsbr p=model q=value]`: combine a defaulted mold with the subject.

## Expands to

```
=+(*p q)
```

## Syntax

Regular: *2-fixed*.

## Discussion

`=|` "declares a variable" which is "uninitialized," presumably 
because you'll set it in a loop or similar.

## Examples

```
~zod:dojo> =foo  |=  a=@
                 =|  b=@
                 =-  :(add a b c)
                 c=2 
~zod:dojo> (foo 5)
7
```
---
navhome: /docs/
next: true
sort: 5
title: =- "tishep"
---

# `=- "tishep"`

`[%tshp p=hoon q=hoon]`: combine a new noun with the subject, inverted.

## Expands to

```
=>([q .] p)
```

## Syntax

Regular: *2-fixed*.

## Discussion

`=-` looks better than `=+` when the hoon you're pinning 
is much smaller than the hoon that uses it.

## Examples
 
```
~zod:dojo> =foo  |=  a=@
                 =+  b=1
                 =-  (add a b c)
                 c=2 
~zod:dojo> (foo 5)
8
```
---
navhome: /docs/
next: true
sort: 13
title: =, "tiscom"
---

# `=, "tiscom"` 

`[%tscm p=hoon q=hoon]`: expose namespace

`p` evaluates to a noun with some namespace.  From within `q` you may access `p`'s 
names without a wing path (i.e., you can use face `b` rather than `b.p`), or without 
invoking a core name when `p` is a core.  This is especially useful for calling arms 
from an imported library or for calling arms from an stdlib core repeatedly.

## Syntax

Regular: *2-fixed*.

## Examples

With a core:

```
> (sum -7 --7)
-find.sum
[crash message]

> (sum:si -7 --7)
--0

> =,  si  (sum -7 --7)
--0
```

With a dojo-defined face:

```
> =/  fan  [bab=2 baz=[3 qux=4]]
  =,  fan
  [bab qux.baz]
[2 4]
```
---
navhome: /docs/
next: true
sort: 3
title: !> "zapgar"
---

# `!> "zapgar"`

`[%zpgr p=hoon]`: wrap a noun in its type.

## Produces

A cell whose tail is `p`, and whose head is the static type of p.

## Syntax

Regular: *1-fixed*.

## Discussion

In Hoon, dynamic type is static type compiled at runtime.  This
type-noun cell is generally called a `vase`.

## Examples

```
~zod:dojo> !>(1)
[p=#t/@ud q=1]
```
---
navhome: /docs/
next: true
sort: 2
title: != "zaptis"
---

# `!= "zaptis"`

`[%zpts p=hoon]`: make the Nock formula for a hoon.

## Produces

The Nock generated by `p`.

## Syntax

Regular: *1-fixed*.

## Examples

```
~zod:dojo> !=(20)
[1 20]
~zod:dojo> !=(~zod)
[1 0]
~zod:dojo> !=((add 2 2))
[8 [9 3.110.356 0 31] 9 2 [0 4] [7 [0 3] 1 2 2] 0 11]
```
---
navhome: /docs/
sort: 4
title: !? "zapwut"
---

# `!? "zapwut"`

`[%zpwt p=@ q=hoon]`: restrict Hoon version.

## Produces

`q`, if `p` is greater than or equal to the Hoon kelvin version.
(Versions count down; the current version is 143.)

## Syntax

Regular: *2-fixed*.

## Examples

```
~zod:dojo> !?(264 (add 2 2))
4
~zod:dojo> !?(164 (add 2 2))
4
~zod:dojo> !?(64 (add 2 2))
! exit
```
